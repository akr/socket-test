<%

# Copyright (C) 2013 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'pp'
include ERB::Util # for ERB::Util#h and ERB::Util#u
require 'tsort'

def shared_prefix_length(str1, str2)
  (0..str1.length).find {|i| str1[i] != str2[i] } || str1.length
end

class Graph
  include TSort
  def initialize
    @child_parents = {}
    @node_order = nil
  end
  attr_accessor :node_order
  def []=(child, parents)
    @child_parents[child] = parents
  end
  def [](child)
    @child_parents[child]
  end
  def tsort_each_node(&b)
    if @node_order
      @node_order.each(&b)
    else
      @child_parents.each_key(&b)
    end
  end
  def init_node_order
    return if @node_order
    distance_from_start = {}
    self.tsort_each {|e2|
      d = self[e2].map {|e1| distance_from_start[e1] }.max || 0
      distance_from_start[e2] = d+1
    }
    has_child = {}
    @child_parents.each_key {|child|
      has_child[child] = false
    }
    @child_parents.each {|child, parents|
      parents.each {|parent|
        has_child[parent] = true
      }
    }
    nodes_has_child, nodes_no_child = has_child.keys.partition {|node|
      has_child[node]
    }
    self.node_order = nodes_no_child.sort_by {|node|
      shprefixlen = @child_parents[node].map {|parent|
        shared_prefix_length(node, parent)
      }.min || 0
      [distance_from_start[node], -shprefixlen]
    } + nodes_has_child
  end
  def tsort_each_child(child, &b)
    # child-parent relation is reversed between tsort.rb and this class.
    if @child_parents.has_key? child
      @child_parents[child].each(&b)
    end
  end
end

def merge_orderd(*arys)
  g = Graph.new
  arys.each {|ary|
    h = Hash.new(0)
    ary2 = ary.map {|e|
      h[e] += 1
      if h[e] == 1
        e
      else
        "#{e}(#{h[e]})"
      end
    }
    1.upto(ary2.length-1) {|i|
      e1 = ary2[i-1]
      e2 = ary2[i]
      (g[e2] ||= []) << e1
    }
    g[ary[0]] ||= []
  }
  g.init_node_order
  merged = []
  g.tsort_each {|e|
    merged << e
  }
  merged
end

files = {}
Dir.glob('results/*.txt') {|filename|
  os = File.basename(filename, '.txt')
  files[os] = File.read(filename)
}

os_list = %w[
  freebsd
  debian-kfreebsd
  darwin
  dragonfly
  netbsd
  openbsd51
  openbsd52
  miros
  hurd
  haiku
  minix
  linux
  linux-arm
  sunos
  cygwin
]
os_order = {}
os_list.each_with_index {|os, i|
  os_order[os] = i
}

files.keys.sort.each_with_index {|os, i|
  os_order[os] ||= -i
}

command_os_lines = {}
files.keys.sort_by {|os| os_order[os] }.each {|os|
  content = files[os]
  content.lines.slice_before(/\A(uname|\.\/)/).each {|lines|
    lines = lines.reject {|line| /\A\s*\z/ =~ line }
    next if lines.empty?
    command = lines.shift.chomp.rstrip
    command_os_lines[command] ||= {}
    command_os_lines[command][os] = lines
  }
}


uname_results = command_os_lines.delete 'uname -mrsv'
#pp uname_results
#pp command_os_lines

command_os_action_result_pairs = {}
command_os_lines.each {|command, os_lines|
  os_lines.each {|os, lines|
    action_result_pairs = lines.map {|line|
      unless /:|=|->|<-/ =~ line
        warn "unexpected line: #{line.inspect}"
        next
      end
      key, sep, result = $`, $&, $'
      key = key.strip
      case sep
      when ':' then sep = '->'
      when '=' then sep = ''
      end
      result = result.strip
      action = "#{key} #{sep}".strip
      [action, result]
    }.compact
    command_os_action_result_pairs[command] ||= {}
    command_os_action_result_pairs[command][os] = action_result_pairs
  }
}

#pp command_os_action_result_pairs

command_actions = {}
command_actions_order = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  actions_list = os_action_result_pairs.map {|os, action_result_pairs|
    action_result_pairs.map {|action, result|
      action
    }
  }
  command_actions_order[command] = {}
  merged_actions = merge_orderd(*actions_list)
  command_actions[command] = merged_actions
  merged_actions.each_with_index {|action, i|
    command_actions_order[command][action] = i
  }
}

#pp command_actions_order

command_action_os_result = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  action_os_result = {}
  os_action_result_pairs.each {|os, action_result_pairs|
    action_result_pairs.each {|action, result|
      action_os_result[action] ||= {}
      action_os_result[action][os] = result
    }
  }
  command_action_os_result[command] = action_os_result
}

#pp command_action_os_result

# substitute /temp.06477/ to /temp.N/
command_action_os_result2 = {}
command_action_os_result.each {|command, action_os_result|
  command_action_os_result2[command] = {}
  action_os_result.each {|action, os_result|
    command_action_os_result2[command][action] = {}
    os_result.each {|os, result|
      result2 = result.gsub(%r{/temp.\d+/}, '/temp.N/')
      command_action_os_result2[command][action][os] = result2
    }
  }
}
command_action_os_result = command_action_os_result2

# remove results people can interpolate.
#
# ...
# ./unix-stream '(44*"./")a\0'
# ./unix-stream '(44*"./")ab\0'
# ./unix-stream '(45*"./")a\0'
# ...

def shell_split_commandline(commandline)
  args = commandline.split(/\s+/)
  args.map! {|arg| /\A'(.*)'\z/ =~ arg ? $1 : arg }
  args
end

def socket_test_expand_repeatation(str)
  str.gsub(/\((\d+)\*"(.*?)"\)/) { $2 * $1.to_i }
end

def generate_nulloverwrite_substs(command1_args, command2_args, command3_args)
  command1_lens = command1_args.map {|arg| arg.length }
  command2_lens = command2_args.map {|arg| arg.length }
  command3_lens = command3_args.map {|arg| arg.length }

  nulloverwrite_subst_12 = command1_args.map.with_index {|arg, i|
    if command1_lens[i] < command2_lens[i]
      [Regexp.union(arg + '\\0' * (command2_lens[i] - command1_lens[i])), command2_args[i]]
    else
      [Regexp.union(arg), command2_args[i] + '\\0' * (command1_lens[i] - command2_lens[i])]
    end
  }
  nulloverwrite_subst_23 = command2_args.map.with_index {|arg, i|
    if command2_lens[i] < command3_lens[i]
      [Regexp.union(arg + '\\0' * (command3_lens[i] - command2_lens[i])), command3_args[i]]
    else
      [Regexp.union(arg), command3_args[i] + '\\0' * (command2_lens[i] - command3_lens[i])]
    end
  }
  return nulloverwrite_subst_12, nulloverwrite_subst_23
end

def interpolatable_result?(command1, action_os_result1, command2, action_os_result2, command3, action_os_result3)
  #p [:command1, command1]
  #p [:command2, command2]
  #p [:command3, command3]
  command1_ary = shell_split_commandline(command1)
  command2_ary = shell_split_commandline(command2)
  command3_ary = shell_split_commandline(command3)
  if command1_ary.empty? ||
     command1_ary.length != command2_ary.length || 
     command1_ary.length != command3_ary.length || 
     command1_ary[0] != command2_ary[0] ||
     command1_ary[0] != command3_ary[0]
    #p [__LINE__, :command_length]
    return false
  end
  command = command1_ary.shift
  command2_ary.shift
  command3_ary.shift
  command1_opts, command1_args = command1_ary.partition {|arg| /\A-/ =~ arg }
  command2_opts, command2_args = command2_ary.partition {|arg| /\A-/ =~ arg }
  command3_opts, command3_args = command3_ary.partition {|arg| /\A-/ =~ arg }
  if command1_opts != command2_opts || command2_opts != command3_opts ||
     command1_args.length != command2_args.length || command1_args.length != command3_args.length
    #p [__LINE__, :command_args]
    return false
  end
  command1_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command2_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command3_args.map! {|arg| socket_test_expand_repeatation(arg) }
  (command1_args.length-1).downto(0) {|i|
    if command1_args[i] == command2_args[i] && command2_args[i] == command3_args[i]
      command1_args.delete_at(i)
      command2_args.delete_at(i)
      command3_args.delete_at(i)
    elsif command1_args[i] == command2_args[i] || command2_args[i] == command3_args[i]
      #p [__LINE__, :command_args2]
      return false
    end
  }

  simple_subst_12 = command1_args.map.with_index {|arg, i| [Regexp.union(arg), command2_args[i]] }
  simple_subst_23 = command2_args.map.with_index {|arg, i| [Regexp.union(arg), command3_args[i]] }

  nulloverwrite_subst_12, nulloverwrite_subst_23 = generate_nulloverwrite_substs(command1_args, command2_args, command3_args)

  command1_unredundant_args = command1_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command2_unredundant_args = command2_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command3_unredundant_args = command3_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  nulloverwrite_unredandant_subst_12, nulloverwrite_unredandant_subst_23 =
    generate_nulloverwrite_substs(command1_unredundant_args, command2_unredundant_args, command3_unredundant_args)

  if action_os_result1.keys.sort != action_os_result2.keys.sort ||
     action_os_result1.keys.sort != action_os_result3.keys.sort
    #p [__LINE__, :not_interpolatable, :action_os]
    return false
  end
  action_os_result1.each {|action, os_result1|
    os_result2 = action_os_result2[action]
    os_result3 = action_os_result3[action]
    if os_result1.keys.sort != os_result2.keys.sort ||
       os_result1.keys.sort != os_result3.keys.sort
      #p [__LINE__, :not_interpolatable, :action, action]
      return false
    end
    os_result1.each {|os, result1|
      result2 = os_result2[os]
      result3 = os_result3[os]
      next if result1 == result2 && result2 == result3
      if /unix/ =~ command &&
        (m1 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result1)) &&
        (m2 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result2)) &&
        (m3 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result3)) &&
        m1[1] == m2[1] && m2[1] == m3[1] &&
        m1[2] != m2[2] && m2[2] != m3[2] && m3[2] != m1[2] &&
        m1[3] == m2[3] && m2[3] == m3[3]
        # Cygwin can return AF_INET sockaddr for AF_UNIX socket operations.
        next
      end
      if !((m1 = /\A"(.*)" \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)" \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)" \((\d+) bytes\)\z/.match(result3))) &&
         !((m1 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result3)))
        #pp [__LINE__, action, os, result1, result2, result3]
        return false
      end
      socklen1 = m1[2].to_i
      socklen2 = m2[2].to_i
      socklen3 = m3[2].to_i
      if (socklen1 == socklen2) ^ (socklen2 == socklen3)
        #p [__LINE__, action, os]
        return false
      end
      expanded_sockaddr1 = socket_test_expand_repeatation(m1[1])
      expanded_sockaddr2 = socket_test_expand_repeatation(m2[1])
      expanded_sockaddr3 = socket_test_expand_repeatation(m3[1])
      if (0...simple_subst_12.length).any? {|i|
           pat12, repl12 = simple_subst_12[i]
           pat23, repl23 = simple_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if nulloverwrite_subst_12 && nulloverwrite_subst_23 &&
         (0...nulloverwrite_subst_12.length).any? {|i|
           pat12, repl12 = nulloverwrite_subst_12[i]
           pat23, repl23 = nulloverwrite_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if nulloverwrite_unredandant_subst_12 && nulloverwrite_unredandant_subst_23 &&
         (0...nulloverwrite_unredandant_subst_12.length).any? {|i|
           pat12, repl12 = nulloverwrite_unredandant_subst_12[i]
           pat23, repl23 = nulloverwrite_unredandant_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if /haiku/ =~ os &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr1 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr2 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr3
        #p [expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
        next
      end
      #pp [__LINE__, action, os, command1, command2, command3, 
      #    command1_args, command2_args, command3_args,
      #    result1, result2, result3,
      #    expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
      return false
    }
  }
  true
end

def remove_interpolatable_commands(command_action_os_result)
  command_action_os_result2 = {}
  command_action_os_result_ary = command_action_os_result.to_a
  command_action_os_result_ary.each_with_index {|(command, action_os_result), i|
    if i == 0 || i == command_action_os_result_ary.length - 1
      command_action_os_result2[command] = action_os_result
    else
      above_command, above_action_os_result = command_action_os_result_ary[i-1]
      below_command, below_action_os_result = command_action_os_result_ary[i+1]
      #next if command != "./unix-dgram '(91*\"c\")\\0'  '(91*\"c\")\\0'  'bar\\0'" # for debug
      if !interpolatable_result?(above_command, above_action_os_result,
                                 command, action_os_result,
                                 below_command, below_action_os_result)
        command_action_os_result2[command] = action_os_result
        #puts "not interpolatable: #{command.inspect}" # for debug
      else
        #puts "interpolatable: #{command.inspect}" # for debug
      end
      #exit # for debug
    end
  }
  command_action_os_result2
end

command_action_os_result = remove_interpolatable_commands(command_action_os_result)

command_action_os_style = {}
command_action_os_result.each {|command, action_os_result|
  os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
  command_action_os_style[command] ||= {}
  action_os_result.each {|action, os_result|
    command_action_os_style[command][action] ||= {}
    count = Hash.new(0)
    os_result.each_value {|result|
      count[result] += 1
    }
    max = count.values.max
    normal_result = count.to_a.rassoc(max)[0]
    os_result.each {|os, result|
      if result == normal_result
        command_action_os_style[command][action][os] = "socket-normal"
      else
        command_action_os_style[command][action][os] = "socket-abnormal"
      end
    }
    os_list.each {|os|
      unless os_result.has_key? os
        command_action_os_style[command][action][os] = "socket-none"
      end
    }
  }
}

#pp command_action_os_result

def command2fragment(command)
  command.sub(%r{\A\./}, "").gsub(%r{[^a-zA-Z0-9./-]}, "")
end

%>
<html>
  <head>
    <title>Unix domain socket behavior comparison</title>
    <style type="text/css">
      .socket-normal { background: white; }
      .socket-abnormal { background: #FA8072; }
      .socket-none { background: gray; }
      table {
        border: 1px;
        border-collapse:collapse;
      }
      th {
        background: black;
        color: white;
      }
    </style>
  </head>
<body>

<h1>Unix domain socket behavior comparison</h1>

<h2>contents</h2>
<ul>
% if uname_results
  <li><a href="#uname">uname</a></li>
% end
% command_action_os_result.each {|command, action_os_result|
%   frag = command2fragment(command)
  <li><a href="#<%= h(u(frag)) %>"><%=h command %></a></li>
% }
</ul>

% if uname_results
<h2><a name="uname">uname</a></h2>
<table border>
  <tr> <th align="left">OS</th> <th>uname</th> </tr>
%   uname_results.keys.sort_by {|os| os_order[os] }.each {|os|
%     uname = uname_results[os].join
  <tr> <th align="left"><%=h os %></th> <td><%=h uname %></td> </tr>
%   }
</table>
% end

% command_action_os_result.each {|command, action_os_result|
%   os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
%   frag = command2fragment(command)
<h2><a name="<%= h(u(frag)) %>"><%=h command %></a></h2>
<table border>
  <tr>
    <th align="right">OS</th>
% os_list.each {|os|
    <th><%=h os %></th>
% }
  </tr>
% sorted_actions = action_os_result.keys.sort_by {|action|
%   command_actions_order[command][action]
% }
% sorted_actions.each {|action|
%   os_result = action_os_result[action]
  <tr>
    <th align="left"><%=h action %></th>
%   os_list.each {|os|
      <td class="<%=h command_action_os_style[command][action][os] %>"><%=h os_result[os] %></td>
%   }
  </tr>
% }
  </tr>
</table>
% }

<a href="https://github.com/akr/socket-test">generated by socket-test</a>
</body>
</html>
