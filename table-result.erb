<%

# Copyright (C) 2013 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'pp'
include ERB::Util # for ERB::Util#h
require 'tsort'

class Graph
  include TSort
  def initialize
    @h = {}
  end
  def []=(k, v)
    @h[k] = v
  end
  def [](k)
    @h[k]
  end
  def tsort_each_node(&b)
    @h.each_key(&b)
  end
  def tsort_each_child(node, &b)
    if @h.has_key? node
      @h[node].each(&b)
    end
  end
end

def merge_orderd(*arys)
  g = Graph.new
  arys.each {|ary|
    h = Hash.new(0)
    ary2 = ary.map {|e|
      h[e] += 1
      if h[e] == 1
        e
      else
        "#{e}(#{h[e]})"
      end
    }
    1.upto(ary2.length-1) {|i|
      e1 = ary2[i-1]
      e2 = ary2[i]
      (g[e2] ||= []) << e1
    }
  }
  merged = []
  g.tsort_each {|e|
    merged << e
  }
  merged
end

files = {}
Dir.glob('results/*.txt') {|filename|
  os = File.basename(filename, '.txt')
  files[os] = File.read(filename)
}

os_list = %w[
  freebsd
  debian-kfreebsd
  darwin
  dragonfly
  netbsd
  openbsd51
  openbsd52
  miros
  hurd
  haiku
  minix
  linux
  linux-arm
  sunos
  cygwin
]
os_order = {}
os_list.each_with_index {|os, i|
  os_order[os] = i
}

files.keys.sort.each_with_index {|os, i|
  os_order[os] ||= -i
}

command_os_lines = {}
files.keys.sort_by {|os| os_order[os] }.each {|os|
  content = files[os]
  content.lines.slice_before(/\A(uname|\.\/)/).each {|lines|
    lines = lines.reject {|line| /\A\s*\z/ =~ line }
    next if lines.empty?
    command = lines.shift.chomp.rstrip
    command_os_lines[command] ||= {}
    command_os_lines[command][os] = lines
  }
}


uname_results = command_os_lines.delete 'uname -mrsv'
#pp uname_results
#pp command_os_lines

command_os_action_result_pairs = {}
command_os_lines.each {|command, os_lines|
  os_lines.each {|os, lines|
    action_result_pairs = lines.map {|line|
      unless /:|=|->|<-/ =~ line
        warn "unexpected line: #{line.inspect}"
        next
      end
      key, sep, result = $`, $&, $'
      key = key.strip
      case sep
      when ':' then sep = '->'
      when '=' then sep = ''
      end
      result = result.strip
      action = "#{key} #{sep}".strip
      [action, result]
    }.compact
    command_os_action_result_pairs[command] ||= {}
    command_os_action_result_pairs[command][os] = action_result_pairs
  }
}

#pp command_os_action_result_pairs

command_actions = {}
command_actions_order = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  actions_list = os_action_result_pairs.map {|os, action_result_pairs|
    action_result_pairs.map {|action, result|
      action
    }
  }
  command_actions_order[command] = {}
  merged_actions = merge_orderd(*actions_list)
  command_actions[command] = merged_actions
  merged_actions.each_with_index {|action, i|
    command_actions_order[command][action] = i
  }
}

#pp command_actions_order

command_action_os_result = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  action_os_result = {}
  os_action_result_pairs.each {|os, action_result_pairs|
    action_result_pairs.each {|action, result|
      action_os_result[action] ||= {}
      action_os_result[action][os] = result
    }
  }
  command_action_os_result[command] = action_os_result
}

#pp command_action_os_result

# substitute /temp.06477/ to /temp.N/
command_action_os_result2 = {}
command_action_os_result.each {|command, action_os_result|
  command_action_os_result2[command] = {}
  action_os_result.each {|action, os_result|
    command_action_os_result2[command][action] = {}
    os_result.each {|os, result|
      result2 = result.gsub(%r{/temp.\d+/}, '/temp.N/')
      command_action_os_result2[command][action][os] = result2
    }
  }
}
command_action_os_result = command_action_os_result2

# remove results people can interpolate.
#
# ...
# ./unix-stream '(44*"./")a\0'
# ./unix-stream '(44*"./")ab\0'
# ./unix-stream '(45*"./")a\0'
# ...

def shell_split_commandline(commandline)
  args = commandline.split(/\s+/)
  args.map! {|arg| /\A'(.*)'\z/ =~ arg ? $1 : arg }
  args
end

def socket_test_expand_repeatation(str)
  str.gsub(/\((\d+)\*"(.*?)"\)/) { $2 * $1.to_i }
end

def generate_nulloverwrite_substs(command1_args, command2_args, command3_args)
  command1_lens = command1_args.map {|arg| arg.length }
  command2_lens = command2_args.map {|arg| arg.length }
  command3_lens = command3_args.map {|arg| arg.length }

  nulloverwrite_subst_12 = command1_args.map.with_index {|arg, i|
    if command1_lens[i] < command2_lens[i]
      [Regexp.union(arg + '\\0' * (command2_lens[i] - command1_lens[i])), command2_args[i]]
    else
      [Regexp.union(arg), command2_args[i] + '\\0' * (command1_lens[i] - command2_lens[i])]
    end
  }
  nulloverwrite_subst_23 = command2_args.map.with_index {|arg, i|
    if command2_lens[i] < command3_lens[i]
      [Regexp.union(arg + '\\0' * (command3_lens[i] - command2_lens[i])), command3_args[i]]
    else
      [Regexp.union(arg), command3_args[i] + '\\0' * (command2_lens[i] - command3_lens[i])]
    end
  }
  return nulloverwrite_subst_12, nulloverwrite_subst_23
end

def interpolatable_result?(command1, action_os_result1, command2, action_os_result2, command3, action_os_result3)
  command1_ary = shell_split_commandline(command1)
  command2_ary = shell_split_commandline(command2)
  command3_ary = shell_split_commandline(command3)
  if command1_ary.empty? ||
     command1_ary.length != command2_ary.length || 
     command1_ary.length != command3_ary.length || 
     command1_ary[0] != command2_ary[0] ||
     command1_ary[0] != command3_ary[0]
    return false
  end
  command1_ary.shift
  command2_ary.shift
  command3_ary.shift
  command1_opts, command1_args = command1_ary.partition {|arg| /\A-/ =~ arg }
  command2_opts, command2_args = command2_ary.partition {|arg| /\A-/ =~ arg }
  command3_opts, command3_args = command3_ary.partition {|arg| /\A-/ =~ arg }
  if command1_opts != command2_opts || command2_opts != command3_opts ||
     command1_args.length != command2_args.length || command1_args.length != command3_args.length
    return false
  end
  command1_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command2_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command3_args.map! {|arg| socket_test_expand_repeatation(arg) }
  (command1_args.length-1).downto(0) {|i|
    if command1_args[i] == command2_args[i] && command2_args[i] == command3_args[i]
      command1_args.delete_at(i)
      command2_args.delete_at(i)
      command3_args.delete_at(i)
    elsif command1_args[i] == command2_args[i] || command2_args[i] == command3_args[i]
      return false
    end
  }

  simple_subst_12 = command1_args.map.with_index {|arg, i| [Regexp.union(arg), command2_args[i]] }
  simple_subst_23 = command2_args.map.with_index {|arg, i| [Regexp.union(arg), command3_args[i]] }

  nulloverwrite_subst_12, nulloverwrite_subst_23 = generate_nulloverwrite_substs(command1_args, command2_args, command3_args)

  command1_unredundant_args = command1_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command2_unredundant_args = command2_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command3_unredundant_args = command3_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  nulloverwrite_unredandant_subst_12, nulloverwrite_unredandant_subst_23 =
    generate_nulloverwrite_substs(command1_unredundant_args, command2_unredundant_args, command3_unredundant_args)

  if action_os_result1.keys.sort != action_os_result2.keys.sort ||
     action_os_result1.keys.sort != action_os_result3.keys.sort
    #p __LINE__
    return false
  end
  action_os_result1.each {|action, os_result1|
    os_result2 = action_os_result2[action]
    os_result3 = action_os_result3[action]
    if os_result1.keys.sort != os_result2.keys.sort ||
       os_result1.keys.sort != os_result3.keys.sort
      #p [__LINE__, action]
      return false
    end
    os_result1.each {|os, result1|
      result2 = os_result2[os]
      result3 = os_result3[os]
      next if result1 == result2 && result2 == result3
      if !((m1 = /\A"(.*)" \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)" \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)" \((\d+) bytes\)\z/.match(result3))) &&
         !((m1 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result3)))
        #pp [__LINE__, action, os, result1, result3, result3]
        return false
      end
      socklen1 = m1[2].to_i
      socklen2 = m2[2].to_i
      socklen3 = m3[2].to_i
      if (socklen1 == socklen2) ^ (socklen2 == socklen3)
        #p [__LINE__, action, os]
        return false
      end
      expanded_sockaddr1 = socket_test_expand_repeatation(m1[1])
      expanded_sockaddr2 = socket_test_expand_repeatation(m2[1])
      expanded_sockaddr3 = socket_test_expand_repeatation(m3[1])
      if simple_subst_12.inject(expanded_sockaddr1) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr2 &&
         simple_subst_23.inject(expanded_sockaddr2) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr3
        next
      end
      if nulloverwrite_subst_12 && nulloverwrite_subst_23 &&
         nulloverwrite_subst_12.inject(expanded_sockaddr1) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr2 &&
         nulloverwrite_subst_23.inject(expanded_sockaddr2) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr3
        next
      end
      if nulloverwrite_unredandant_subst_12 && nulloverwrite_unredandant_subst_23 &&
         nulloverwrite_unredandant_subst_12.inject(expanded_sockaddr1) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr2 &&
         nulloverwrite_unredandant_subst_23.inject(expanded_sockaddr2) {|str, (pat, repl)| str.gsub(pat) { repl } } == expanded_sockaddr3
        next
      end
      if /haiku/ =~ os &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr1 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr2 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr3
        #p [expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
        next
      end
      #p [__LINE__, action, os]
      #p command1
      #p command2
      #p command3
      #pp [command1_args, command2_args, command3_args]
      #pp [result1, result2, result3]
      #pp [expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
      return false
    }
  }
  true
end

def remove_interpolatable_commands(command_action_os_result)
  command_action_os_result2 = {}
  command_action_os_result_ary = command_action_os_result.to_a
  command_action_os_result_ary.each_with_index {|(command, action_os_result), i|
    if i == 0 || i == command_action_os_result_ary.length - 1
      command_action_os_result2[command] = action_os_result
    else
      above_command, above_action_os_result = command_action_os_result_ary[i-1]
      below_command, below_action_os_result = command_action_os_result_ary[i+1]
      #next if command != "./unix-stream -4 '(sun_len=2)abc\\0'" # for debug
      if !interpolatable_result?(above_command, above_action_os_result,
                                 command, action_os_result,
                                 below_command, below_action_os_result)
        command_action_os_result2[command] = action_os_result
      end
      #exit # for debug
    end
  }
  command_action_os_result2
end

command_action_os_result = remove_interpolatable_commands(command_action_os_result)

command_action_os_style = {}
command_action_os_result.each {|command, action_os_result|
  os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
  command_action_os_style[command] ||= {}
  action_os_result.each {|action, os_result|
    command_action_os_style[command][action] ||= {}
    count = Hash.new(0)
    os_result.each_value {|result|
      count[result] += 1
    }
    max = count.values.max
    normal_result = count.to_a.rassoc(max)[0]
    os_result.each {|os, result|
      if result == normal_result
        command_action_os_style[command][action][os] = "socket-normal"
      else
        command_action_os_style[command][action][os] = "socket-abnormal"
      end
    }
    os_list.each {|os|
      unless os_result.has_key? os
        command_action_os_style[command][action][os] = "socket-none"
      end
    }
  }
}

#pp command_action_os_result

%>
<html>
  <head>
    <title>Unix domain socket behavior comparison</title>
    <style type="text/css">
      .socket-normal { background: white; }
      .socket-abnormal { background: #FA8072; }
      .socket-none { background: gray; }
      table {
        border: 1px;
        border-collapse:collapse;
      }
      th {
        background: black;
        color: white;
      }
    </style>
  </head>
<body>

<h1>Unix domain socket behavior comparison</h1>

<h2>uname</h2>
<table border>
  <tr> <th align="left">OS</th> <th>uname</th> </tr>
% uname_results.keys.sort_by {|os| os_order[os] }.each {|os|
%   uname = uname_results[os].join
  <tr> <th align="left"><%=h os %></th> <td><%=h uname %></td> </tr>
% }
</table>

% command_action_os_result.each {|command, action_os_result|
%   os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
<h2><%=h command %></h2>
<table border>
  <tr>
    <th align="right">OS</th>
% os_list.each {|os|
    <th><%=h os %></th>
% }
  </tr>
% action_os_result.keys.sort_by {|action| command_actions_order[command][action] }.each {|action|
%   os_result = action_os_result[action]
  <tr>
    <th align="left"><%=h action %></th>
%   os_list.each {|os|
      <td class="<%=h command_action_os_style[command][action][os] %>"><%=h os_result[os] %></td>
%   }
  </tr>
% }
  </tr>
</table>
% }

<a href="https://github.com/akr/socket-test">generated by socket-test</a>
</body>
</html>
