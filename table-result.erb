<%

# Copyright (C) 2013 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'pp'
include ERB::Util # for ERB::Util#h and ERB::Util#u
require 'tsort'

def shared_prefix_length(str1, str2)
  (0..str1.length).find {|i| str1[i] != str2[i] } || str1.length
end

class Graph
  include TSort
  def initialize
    @child_parents = {}
    @node_order = nil
  end
  attr_accessor :node_order
  def []=(child, parents)
    @child_parents[child] = parents
  end
  def [](child)
    @child_parents[child]
  end
  def tsort_each_node(&b)
    if @node_order
      h = @child_parents.dup
      @node_order.each {|n|
        yield n
        h.delete n
      }
      h.each_key(&b)
    else
      @child_parents.each_key(&b)
    end
  end
  def init_node_order(node_order)
    return if @node_order
    @node_order = node_order
  end
  def tsort_each_child(child, &b)
    # child-parent relation is reversed between tsort.rb and this class.
    if @child_parents.has_key? child
      @child_parents[child].each(&b)
    end
  end
end

def merge_ordered(*arys)
  g = Graph.new
  arys.each {|ary|
    h = Hash.new(0)
    ary2 = ary.map {|e|
      h[e] += 1
      if h[e] == 1
        e
      else
        "#{e}(#{h[e]})"
      end
    }
    1.upto(ary2.length-1) {|i|
      e1 = ary2[i-1]
      e2 = ary2[i]
      (g[e2] ||= []) << e1
    }
    g[ary[0]] ||= []
  }
  ancestors = {}
  descendants = {}
  arys.each {|ary|
    ary.each_with_index {|n, i|
      ancestors[n] ||= {}
      descendants[n] ||= {}
      ary[0, i].each {|a| ancestors[n][a] = true }
      ary[(i+1)..-1].each {|d| descendants[n][d] = true }
    }
  }
  node_order = ancestors.keys.sort_by {|n|
    w = ancestors[n].length * 2
    w += descendants[n].length
    w
  }
  g.init_node_order node_order
  merged = []
  g.tsort_each {|e|
    merged << e
  }
  merged
end

files = {}
Dir.glob('results/*.txt') {|filename|
  os = File.basename(filename, '.txt')
  files[os] = File.read(filename)
}

os_list = %w[
  freebsd
  debian-kfreebsd
  darwin
  dragonfly
  netbsd
  openbsd51
  openbsd52
  miros
  hurd
  haiku
  minix
  linux
  linux-arm
  sunos
  cygwin
]
os_order = {}
os_list.each_with_index {|os, i|
  os_order[os] = i
}

files.keys.sort.each_with_index {|os, i|
  os_order[os] ||= -i
}

commands_ary = []
command_os_lines = {}
files.keys.sort_by {|os| os_order[os] }.each {|os|
  commands_ary << []
  content = files[os]
  content.lines.slice_before(/\A(uname|\.\/)/).each {|lines|
    lines = lines.reject {|line| /\A\s*\z/ =~ line }
    next if lines.empty?
    command = lines.shift.chomp.rstrip
    command_os_lines[command] ||= {}
    command_os_lines[command][os] = lines
    commands_ary.last << command
  }
}
command_list = merge_ordered(*commands_ary)

uname_results = command_os_lines.delete 'uname -mrsv'
#pp uname_results
#pp command_os_lines

command_os_key_sep_result_pairs = {}
command_os_lines.each {|command, os_lines|
  os_lines.each {|os, lines|
    action_subid = Hash.new(0)
    key_sep_result_pairs_ary = []
    lines.each {|line|
      unless /:|=|->|<-/ =~ line
        warn "unexpected line: #{line.inspect}"
        next
      end
      action, sep, result = $`, $&, $'
      action = action.strip
      result = result.strip
      #case sep
      #when ':' then sep = '->'
      #when '=' then sep = ''
      #end
      if !key_sep_result_pairs_ary.empty? &&
        key_sep_result_pairs_ary.last.first.first == action
        key_sep_result_pairs_ary.last.last << [sep, result]
      else
        subid = action_subid[action]
        action_subid[action] += 1
        key = [action, subid]
        key_sep_result_pairs_ary << [key, [[sep, result]]]
      end
    }
    key_sep_result_pairs = {}
    key_sep_result_pairs_ary.each {|key, sep_result_pairs|
      key_sep_result_pairs[key] = sep_result_pairs
    }
    command_os_key_sep_result_pairs[command] ||= {}
    command_os_key_sep_result_pairs[command][os] = key_sep_result_pairs
  }
}
#pp command_os_key_sep_result_pairs

command_os_key_sep_result_pairs2 = {}
command_os_key_sep_result_pairs.each {|command, os_key_sep_result_pairs|
  has_multiple_seps = false
  prev_sep = nil
  catch {|search_multiple_seps|
    os_key_sep_result_pairs.each {|os, key_sep_result_pairs|
      key_sep_result_pairs.each {|key, sep_result_pairs|
        sep_result_pairs.each {|sep, result|
          if prev_sep == nil
            prev_sep = sep
          else
            if prev_sep != sep
              has_multiple_seps = true
              throw search_multiple_seps
            end
          end
        }
      }
    }
  }
  if has_multiple_seps
    command_os_key_sep_result_pairs2[command] = os_key_sep_result_pairs
  else
    os_key_sep_result_pairs2 = {}
    os_key_sep_result_pairs.each {|os, key_sep_result_pairs|
      key_sep_result_pairs.each {|key, sep_result_pairs|
        os_key_sep_result_pairs2[os] ||= {}
        os_key_sep_result_pairs2[os][key] = sep_result_pairs.map {|sep, result| ['', result] }
      }
    }
    command_os_key_sep_result_pairs2[command] = os_key_sep_result_pairs2
  end
}
command_os_key_sep_result_pairs = command_os_key_sep_result_pairs2

command_os_key_sep_result_pairs2 = {}
command_os_key_sep_result_pairs.each {|command, os_key_sep_result_pairs|
  os_key_sep_result_pairs2 = {}
  os_key_sep_result_pairs.each {|os, key_sep_result_pairs|
    key_sep_result_pairs.each {|key, sep_result_pairs|
      os_key_sep_result_pairs2[os] ||= {}
      os_key_sep_result_pairs2[os][key] = sep_result_pairs.map {|sep, result|
        sep = '->' if sep == ':'
        [sep, result]
      }
    }
  }
  command_os_key_sep_result_pairs2[command] = os_key_sep_result_pairs2
}
command_os_key_sep_result_pairs = command_os_key_sep_result_pairs2

command_keys = {}
command_key_order = {}
command_os_key_sep_result_pairs.each {|command, os_key_sep_result_pairs|
  keys_list = os_key_sep_result_pairs.map {|os, key_sep_result_pairs|
    key_sep_result_pairs.map {|key, sep_result_pairs|
      key
    }
  }
  command_key_order[command] = {}
  merged_keys = merge_ordered(*keys_list)
  command_keys[command] = merged_keys
  merged_keys.each_with_index {|key, i|
    command_key_order[command][key] = i
  }
}

#pp command_key_order

command_key_seps = {}
command_key_sep_order = {}
command_os_key_sep_result_pairs.each {|command, os_key_sep_result_pairs|
  command_key_order[command].each_key {|key|
    seps_list = os_key_sep_result_pairs.map {|os, key_sep_result_pairs|
      sep_result_pairs = key_sep_result_pairs[key]
      if sep_result_pairs
        sep_result_pairs.map {|sep, result|
          sep
        }
      else
        nil
      end
    }.compact
    seps = merge_ordered(*seps_list)
    command_key_seps[command] ||= {}
    command_key_seps[command][key] = seps
    command_key_sep_order[command] ||= {}
    command_key_sep_order[command][key] = {}
    seps.each_with_index {|sep, i|
      command_key_sep_order[command][key][sep] = i
    }
  }
}
#pp command_key_seps

command_keysep_os_result = {}
command_os_key_sep_result_pairs.each {|command, os_key_sep_result_pairs|
  keysep_os_result = {}
  os_key_sep_result_pairs.each {|os, key_sep_result_pairs|
    key_sep_result_pairs.each {|key, sep_result_pairs|
      command_key_seps[command][key].each {|sep|
        sep_result_pair = sep_result_pairs.assoc(sep)
        if sep_result_pair
          keysep = key + [sep]
          keysep_os_result[keysep] ||= {}
          keysep_os_result[keysep][os] = sep_result_pair.last
        end
      }
    }
  }
  command_keysep_os_result[command] = keysep_os_result
}
#pp command_keysep_os_result

# substitute /temp.06477/ to /temp.N/
command_keysep_os_result2 = {}
command_keysep_os_result.each {|command, keysep_os_result|
  command_keysep_os_result2[command] = {}
  keysep_os_result.each {|keysep, os_result|
    command_keysep_os_result2[command][keysep] = {}
    os_result.each {|os, result|
      result2 = result.gsub(%r{/temp.\d+/}, '/temp.N/')
      command_keysep_os_result2[command][keysep][os] = result2
    }
  }
}
command_keysep_os_result = command_keysep_os_result2

# remove results people can interpolate.
#
# ...
# ./unix-stream '(44*"./")a\0'
# ./unix-stream '(44*"./")ab\0'
# ./unix-stream '(45*"./")a\0'
# ...

def shell_split_commandline(commandline)
  args = commandline.split(/\s+/)
  args.map! {|arg| /\A'(.*)'\z/ =~ arg ? $1 : arg }
  args
end

def socket_test_expand_repeatation(str)
  str.gsub(/\((\d+)\*"(.*?)"\)/) { $2 * $1.to_i }
end

def generate_nulloverwrite_substs(command1_args, command2_args, command3_args)
  command1_lens = command1_args.map {|arg| arg.length }
  command2_lens = command2_args.map {|arg| arg.length }
  command3_lens = command3_args.map {|arg| arg.length }

  nulloverwrite_subst_12 = command1_args.map.with_index {|arg, i|
    if command1_lens[i] < command2_lens[i]
      [Regexp.union(arg + '\\0' * (command2_lens[i] - command1_lens[i])), command2_args[i]]
    else
      [Regexp.union(arg), command2_args[i] + '\\0' * (command1_lens[i] - command2_lens[i])]
    end
  }
  nulloverwrite_subst_23 = command2_args.map.with_index {|arg, i|
    if command2_lens[i] < command3_lens[i]
      [Regexp.union(arg + '\\0' * (command3_lens[i] - command2_lens[i])), command3_args[i]]
    else
      [Regexp.union(arg), command3_args[i] + '\\0' * (command2_lens[i] - command3_lens[i])]
    end
  }
  return nulloverwrite_subst_12, nulloverwrite_subst_23
end

def interpolatable_result?(command1, keysep_os_result1, command2, keysep_os_result2, command3, keysep_os_result3)
  #p [:command1, command1]
  #p [:command2, command2]
  #p [:command3, command3]
  command1_ary = shell_split_commandline(command1)
  command2_ary = shell_split_commandline(command2)
  command3_ary = shell_split_commandline(command3)
  if command1_ary.empty? ||
     command1_ary.length != command2_ary.length || 
     command1_ary.length != command3_ary.length || 
     command1_ary[0] != command2_ary[0] ||
     command1_ary[0] != command3_ary[0]
    #p [__LINE__, :command_length]
    return false
  end
  command = command1_ary.shift
  command2_ary.shift
  command3_ary.shift
  command1_opts, command1_args = command1_ary.partition {|arg| /\A-/ =~ arg }
  command2_opts, command2_args = command2_ary.partition {|arg| /\A-/ =~ arg }
  command3_opts, command3_args = command3_ary.partition {|arg| /\A-/ =~ arg }
  if command1_opts != command2_opts || command2_opts != command3_opts ||
     command1_args.length != command2_args.length || command1_args.length != command3_args.length
    #p [__LINE__, :command_args]
    return false
  end
  command1_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command2_args.map! {|arg| socket_test_expand_repeatation(arg) }
  command3_args.map! {|arg| socket_test_expand_repeatation(arg) }
  (command1_args.length-1).downto(0) {|i|
    if command1_args[i] == command2_args[i] && command2_args[i] == command3_args[i]
      command1_args.delete_at(i)
      command2_args.delete_at(i)
      command3_args.delete_at(i)
    elsif command1_args[i] == command2_args[i] || command2_args[i] == command3_args[i]
      #p [__LINE__, :command_args2]
      return false
    end
  }

  simple_subst_12 = command1_args.map.with_index {|arg, i| [Regexp.union(arg), command2_args[i]] }
  simple_subst_23 = command2_args.map.with_index {|arg, i| [Regexp.union(arg), command3_args[i]] }

  nulloverwrite_subst_12, nulloverwrite_subst_23 = generate_nulloverwrite_substs(command1_args, command2_args, command3_args)

  command1_unredundant_args = command1_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command2_unredundant_args = command2_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  command3_unredundant_args = command3_args.map {|arg| arg.sub(%r{\A(\./)*}, '') }
  nulloverwrite_unredandant_subst_12, nulloverwrite_unredandant_subst_23 =
    generate_nulloverwrite_substs(command1_unredundant_args, command2_unredundant_args, command3_unredundant_args)

  if keysep_os_result1.keys.sort != keysep_os_result2.keys.sort ||
     keysep_os_result1.keys.sort != keysep_os_result3.keys.sort
    #p [__LINE__, :not_interpolatable, :keysep_os]
    return false
  end
  keysep_os_result1.each {|keysep, os_result1|
    os_result2 = keysep_os_result2[keysep]
    os_result3 = keysep_os_result3[keysep]
    if os_result1.keys.sort != os_result2.keys.sort ||
       os_result1.keys.sort != os_result3.keys.sort
      #p [__LINE__, :not_interpolatable, :keysep, keysep]
      return false
    end
    os_result1.each {|os, result1|
      result2 = os_result2[os]
      result3 = os_result3[os]
      next if result1 == result2 && result2 == result3
      if /unix/ =~ command &&
        (m1 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result1)) &&
        (m2 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result2)) &&
        (m3 = /\A(\d+\.\d+\.\d+\.\d+):(\d+) \((\d+) bytes\)\z/.match(result3)) &&
        m1[1] == m2[1] && m2[1] == m3[1] &&
        m1[2] != m2[2] && m2[2] != m3[2] && m3[2] != m1[2] &&
        m1[3] == m2[3] && m2[3] == m3[3]
        # Cygwin can return AF_INET sockaddr for AF_UNIX socket operations.
        next
      end
      if !((m1 = /\A"(.*)" \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)" \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)" \((\d+) bytes\)\z/.match(result3))) &&
         !((m1 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result1)) &&
           (m2 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result2)) &&
           (m3 = /\A"(.*)"\.\.\. \((\d+) bytes\)\z/.match(result3)))
        #pp [__LINE__, keysep, os, result1, result2, result3]
        return false
      end
      socklen1 = m1[2].to_i
      socklen2 = m2[2].to_i
      socklen3 = m3[2].to_i
      if (socklen1 == socklen2) ^ (socklen2 == socklen3)
        #p [__LINE__, keysep, os]
        return false
      end
      expanded_sockaddr1 = socket_test_expand_repeatation(m1[1])
      expanded_sockaddr2 = socket_test_expand_repeatation(m2[1])
      expanded_sockaddr3 = socket_test_expand_repeatation(m3[1])
      if (0...simple_subst_12.length).any? {|i|
           pat12, repl12 = simple_subst_12[i]
           pat23, repl23 = simple_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if nulloverwrite_subst_12 && nulloverwrite_subst_23 &&
         (0...nulloverwrite_subst_12.length).any? {|i|
           pat12, repl12 = nulloverwrite_subst_12[i]
           pat23, repl23 = nulloverwrite_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if nulloverwrite_unredandant_subst_12 && nulloverwrite_unredandant_subst_23 &&
         (0...nulloverwrite_unredandant_subst_12.length).any? {|i|
           pat12, repl12 = nulloverwrite_unredandant_subst_12[i]
           pat23, repl23 = nulloverwrite_unredandant_subst_23[i]
           expanded_sockaddr1.gsub(pat12) { repl12 } == expanded_sockaddr2 &&
           expanded_sockaddr2.gsub(pat23) { repl23 } == expanded_sockaddr3
         }
        next
      end
      if /haiku/ =~ os &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr1 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr2 &&
         /\A(\(sun_len=8\))?\\0[0-9a-f]{5}\z/ =~ expanded_sockaddr3
        #p [expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
        next
      end
      #pp [__LINE__, keysep, os, command1, command2, command3, 
      #    command1_args, command2_args, command3_args,
      #    result1, result2, result3,
      #    expanded_sockaddr1, expanded_sockaddr2, expanded_sockaddr3]
      return false
    }
  }
  true
end

def remove_interpolatable_commands(command_keysep_os_result)
  command_keysep_os_result2 = {}
  command_keysep_os_result_ary = command_keysep_os_result.to_a
  command_keysep_os_result_ary.each_with_index {|(command, keysep_os_result), i|
    if i == 0 || i == command_keysep_os_result_ary.length - 1
      command_keysep_os_result2[command] = keysep_os_result
    else
      above_command, above_keysep_os_result = command_keysep_os_result_ary[i-1]
      below_command, below_keysep_os_result = command_keysep_os_result_ary[i+1]
      #next if command != "./unix-dgram '(91*\"c\")\\0'  '(91*\"c\")\\0'  'bar\\0'" # for debug
      if !interpolatable_result?(above_command, above_keysep_os_result,
                                 command, keysep_os_result,
                                 below_command, below_keysep_os_result)
        command_keysep_os_result2[command] = keysep_os_result
        #puts "not interpolatable: #{command.inspect}" # for debug
      else
        #puts "interpolatable: #{command.inspect}" # for debug
      end
      #exit # for debug
    end
  }
  command_keysep_os_result2
end

command_keysep_os_result = remove_interpolatable_commands(command_keysep_os_result)

#pp command_keysep_os_result

command_list.reject! {|command|
  !command_keysep_os_result.has_key?(command)
}

command_keysep_os_style = {}
command_keysep_os_result.each {|command, keysep_os_result|
  os_list = keysep_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
  command_keysep_os_style[command] ||= {}
  keysep_os_result.each {|keysep, os_result|
    command_keysep_os_style[command][keysep] ||= {}
    count = Hash.new(0)
    os_result.each_value {|result|
      count[result] += 1
    }
    max = count.values.max
    normal_result = count.to_a.rassoc(max)[0]
    os_result.each {|os, result|
      if result == normal_result
        command_keysep_os_style[command][keysep][os] = "socket-normal"
      else
        command_keysep_os_style[command][keysep][os] = "socket-abnormal"
      end
    }
    os_list.each {|os|
      unless os_result.has_key? os
        command_keysep_os_style[command][keysep][os] = "socket-none"
      end
    }
  }
}

def command2fragment(command)
  command.sub(%r{\A\./}, "").gsub(%r{[^a-zA-Z0-9./-]}, "")
end

%>
<html>
  <head>
    <title>Unix domain socket behavior comparison</title>
    <style type="text/css">
      .socket-normal { background: white; }
      .socket-abnormal { background: #FA8072; }
      .socket-none { background: gray; }
      table {
        border: 1px;
        border-collapse:collapse;
      }
      th {
        background: black;
        color: white;
      }
    </style>
  </head>
<body>

<h1>Unix domain socket behavior comparison</h1>

% if uname_results
<h2><a name="uname">uname</a></h2>
<table border>
  <tr> <th align="left">OS</th> <th>uname</th> </tr>
%   uname_results.keys.sort_by {|os| os_order[os] }.each {|os|
%     uname = uname_results[os].join
  <tr> <th align="left"><%=h os %></th> <td><%=h uname %></td> </tr>
%   }
</table>
% end

<h2>contents</h2>

<ul>
% command_list.each {|command|
%   keysep_os_result = command_keysep_os_result[command]
%   frag = command2fragment(command)
  <li><a href="#<%= h(u(frag)) %>"><%=h command %></a></li>
% }
</ul>

% command_list.each {|command|
%   keysep_os_result = command_keysep_os_result[command]
%   os_list = keysep_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
%   frag = command2fragment(command)
<h2><a name="<%= h(u(frag)) %>"><%=h command %></a></h2>
<table border>
  <tr>
    <th align="right">OS</th>
% os_list.each {|os|
    <th><%=h os %></th>
% }
  </tr>
% sorted_keyseps = keysep_os_result.keys.sort_by {|keysep|
%   action, subid, sep = keysep
%   key = [action, subid]
%   [command_key_order[command][key],
%    command_key_sep_order[command][key][sep]]
% }
% sorted_keyseps.each {|keysep|
%   os_result = keysep_os_result[keysep]
%   key, subid, sep = keysep
%   action = sep.empty? ? key : "#{key} #{sep}"
  <tr>
    <th align="left"><%=h action %></th>
%   os_list.each {|os|
      <td class="<%=h command_keysep_os_style[command][keysep][os] %>"><%=h os_result[os] %></td>
%   }
  </tr>
% }
  </tr>
</table>
% }

<a href="https://github.com/akr/socket-test">generated by socket-test</a>
</body>
</html>
