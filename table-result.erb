<%

# Copyright (C) 2013 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'pp'
include ERB::Util # for ERB::Util#h

def shared_prefix_length(str1, str2)
  (0..str1.length).find {|i| str1[i] != str2[i] } || str1.length
end

def merge_orderd(*arys)
  merged = []
  arys.each {|ary|
    ary = ary.dup
    h = Hash.new(0)
    merged.each {|e| h[e] += 1 }
    ary.each {|e| h[e] += 1 }
    merged2 = []
    while !merged.empty? && !ary.empty?
      if merged.first == ary.first
        merged2 << merged.first
        merged.shift
        ary.shift
      elsif h[merged.first] == 1 && h[ary.first] == 1
        # ambiguous.  needs heuristics.
        if !merged2.empty?
          if shared_prefix_length(merged2.last, merged.first) < shared_prefix_length(merged2.last, ary.first)
            merged2 << ary.first
            ary.shift
          else
            merged2 << merged.first
            merged.shift
          end
        else
          merged2 << merged.first
          merged.shift
        end
      elsif h[merged.first] == 1
        merged2 << merged.first
        merged.shift
      elsif h[ary.first] == 1
        merged2 << ary.first
        ary.shift
      else
        warn "inconsistent elements: #{merged.first.inspect}(#{h[merged.first]}) v.s. #{ary.first.inspect}(#{h[ary.first]})"
        merged2 << merged.first
        merged.shift
      end
    end
    merged2.concat merged
    merged2.concat ary
    merged = merged2
  }
  merged
end

files = {}
Dir.glob('results/*.txt') {|filename|
  os = File.basename(filename, '.txt')
  files[os] = File.read(filename)
}

os_order = {
  'freebsd' => 10,
  'debian-kfreebsd' => 20,
  'darwin' => 30,
  'dragonfly' => 40,
  'netbsd' => 50,
  'openbsd51' => 60,
  'openbsd52' => 70,
  'miros' => 80,
  'hurd' => 90,
  'haiku' => 100,
  'minix' => 110,
  'linux' => 120,
  'linux-arm' => 130,
  'sunos' => 140,
  'cygwin' => 150,
}
files.keys.sort.each_with_index {|os, i|
  os_order[os] ||= i
}

command_os_lines = {}
files.keys.sort_by {|os| os_order[os] }.each {|os|
  content = files[os]
  content.lines.slice_before(/\A(uname|\.\/)/).each {|lines|
    lines = lines.reject {|line| /\A\s*\z/ =~ line }
    next if lines.empty?
    command = lines.shift.chomp.rstrip
    command_os_lines[command] ||= {}
    command_os_lines[command][os] = lines
  }
}


uname_results = command_os_lines.delete 'uname -mrsv'
#pp uname_results
#pp command_os_lines

command_os_action_result_pairs = {}
command_os_lines.each {|command, os_lines|
  os_lines.each {|os, lines|
    action_result_pairs = lines.map {|line|
      unless /:|=|->|<-/ =~ line
        warn "unexpected line: #{line.inspect}"
        next
      end
      result = $'.strip
      action = "#{$`}#{$&}".sub(/(:|=)\z/, '').strip
      [action, result]
    }.compact
    command_os_action_result_pairs[command] ||= {}
    command_os_action_result_pairs[command][os] = action_result_pairs
  }
}

#pp command_os_action_result_pairs

command_actions = {}
command_actions_order = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  actions_list = os_action_result_pairs.map {|os, action_result_pairs|
    action_result_pairs.map {|action, result|
      action
    }
  }
  command_actions_order[command] = {}
  merged_actions = merge_orderd(*actions_list)
  command_actions[command] = merged_actions
  merged_actions.each_with_index {|action, i|
    command_actions_order[command][action] = i
  }
}

#pp command_actions_order

command_action_os_result = {}
command_os_action_result_pairs.each {|command, os_action_result_pairs|
  action_os_result = {}
  os_action_result_pairs.each {|os, action_result_pairs|
    action_result_pairs.each {|action, result|
      action_os_result[action] ||= {}
      action_os_result[action][os] = result
    }
  }
  command_action_os_result[command] = action_os_result
}

command_action_os_style = {}
command_action_os_result.each {|command, action_os_result|
  os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
  command_action_os_style[command] ||= {}
  action_os_result.each {|action, os_result|
    command_action_os_style[command][action] ||= {}
    count = Hash.new(0)
    os_result.each_value {|result|
      count[result] += 1
    }
    max = count.values.max
    normal_result = count.to_a.rassoc(max)[0]
    os_result.each {|os, result|
      if result == normal_result
        command_action_os_style[command][action][os] = "socket-normal"
      else
        command_action_os_style[command][action][os] = "socket-abnormal"
      end
    }
    os_list.each {|os|
      unless os_result.has_key? os
        command_action_os_style[command][action][os] = "socket-none"
      end
    }
  }
}

#pp command_action_os_result

%>
<html>
  <head>
    <title>Unix domain socket behavior comparison</title>
    <style type="text/css">
      .socket-normal { background: white; }
      .socket-abnormal { background: #FA8072; }
      .socket-none { background: gray; }
      table {
        border: 1px;
        border-collapse:collapse;
      }
      th {
        background: black;
        color: white;
      }
    </style>
  </head>
<body>

<h1>Unix domain socket behavior comparison</h1>

<h2>uname</h2>
<table border>
  <tr> <th align="left">OS</th> <th>uname</th> </tr>
% uname_results.keys.sort_by {|os| os_order[os] }.each {|os|
%   uname = uname_results[os].join
  <tr> <th align="left"><%=h os %></th> <td><%=h uname %></td> </tr>
% }
</table>

% command_action_os_result.each {|command, action_os_result|
%   os_list = action_os_result.values.map {|os_result| os_result.keys }.inject(&:|).sort_by {|os| os_order[os] }
<h2><%=h command %></h2>
<table border>
  <tr>
    <th align="right">OS</th>
% os_list.each {|os|
    <th><%=h os %></th>
% }
  </tr>
% action_os_result.keys.sort_by {|action| command_actions_order[command][action] }.each {|action|
%   os_result = action_os_result[action]
  <tr>
    <th align="left"><%=h action %></th>
%   os_list.each {|os|
      <td class="<%=h command_action_os_style[command][action][os] %>"><%=h os_result[os] %></td>
%   }
  </tr>
% }
  </tr>
</table>
% }

<a href="https://github.com/akr/socket-test">generated by socket-test</a>
</body>
</html>
